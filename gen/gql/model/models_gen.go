// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type AggFilter struct {
	Filter    *Filter `json:"filter"`
	Aggregate string  `json:"aggregate"`
	Field     string  `json:"field"`
}

type Authorizer struct {
	Name       string `json:"name"`
	Expression string `json:"expression"`
}

type AuthorizerInput struct {
	Name       string `json:"name"`
	Expression string `json:"expression"`
}

type Authorizers struct {
	Authorizers []*Authorizer `json:"authorizers"`
}

type AuthorizersInput struct {
	Authorizers []*AuthorizerInput `json:"authorizers"`
}

type CFilter struct {
	DocPath    *PathInput `json:"doc_path"`
	Gtype      string     `json:"gtype"`
	Expression *string    `json:"expression"`
	Limit      int        `json:"limit"`
	Sort       *string    `json:"sort"`
	Seek       *string    `json:"seek"`
	Reverse    *bool      `json:"reverse"`
}

type ChanFilter struct {
	Channel    string  `json:"channel"`
	Expression *string `json:"expression"`
}

type Change struct {
	Method        string    `json:"method"`
	Identity      *Doc      `json:"identity"`
	Timestamp     time.Time `json:"timestamp"`
	PathsAffected *Paths    `json:"paths_affected"`
}

type Connection struct {
	Path       *Path                  `json:"path"`
	Attributes map[string]interface{} `json:"attributes"`
	Directed   bool                   `json:"directed"`
	From       *Path                  `json:"from"`
	To         *Path                  `json:"to"`
	Metadata   *Metadata              `json:"metadata"`
}

type ConnectionConstructor struct {
	Path       *PathConstructor       `json:"path"`
	Directed   bool                   `json:"directed"`
	Attributes map[string]interface{} `json:"attributes"`
	From       *PathInput             `json:"from"`
	To         *PathInput             `json:"to"`
}

type Connections struct {
	Connections []*Connection `json:"connections"`
	SeekNext    string        `json:"seek_next"`
}

type Doc struct {
	Path       *Path                  `json:"path"`
	Attributes map[string]interface{} `json:"attributes"`
	Metadata   *Metadata              `json:"metadata"`
}

type DocConstructor struct {
	Path       *PathConstructor       `json:"path"`
	Attributes map[string]interface{} `json:"attributes"`
}

type Docs struct {
	Docs     []*Doc `json:"docs"`
	SeekNext string `json:"seek_next"`
}

type EFilter struct {
	Filter     *Filter                `json:"filter"`
	Attributes map[string]interface{} `json:"attributes"`
}

type Edit struct {
	Path       *PathInput             `json:"path"`
	Attributes map[string]interface{} `json:"attributes"`
}

type ExprFilter struct {
	Expression *string `json:"expression"`
}

type Filter struct {
	Gtype      string  `json:"gtype"`
	Expression *string `json:"expression"`
	Limit      int     `json:"limit"`
	Sort       *string `json:"sort"`
	Seek       *string `json:"seek"`
	Reverse    *bool   `json:"reverse"`
	Index      *string `json:"index"`
}

type Index struct {
	Name        string `json:"name"`
	Gtype       string `json:"gtype"`
	Expression  string `json:"expression"`
	Docs        *bool  `json:"docs"`
	Connections *bool  `json:"connections"`
}

type IndexInput struct {
	Name        string `json:"name"`
	Gtype       string `json:"gtype"`
	Expression  string `json:"expression"`
	Docs        *bool  `json:"docs"`
	Connections *bool  `json:"connections"`
}

type Indexes struct {
	Indexes []*Index `json:"indexes"`
}

type IndexesInput struct {
	Indexes []*IndexInput `json:"indexes"`
}

type Message struct {
	Channel   string                 `json:"channel"`
	Data      map[string]interface{} `json:"data"`
	Sender    *Path                  `json:"sender"`
	Timestamp time.Time              `json:"timestamp"`
}

type Metadata struct {
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	CreatedBy *Path     `json:"createdBy"`
	UpdatedBy *Path     `json:"updated_by"`
	Version   int       `json:"version"`
}

type OutboundMessage struct {
	Channel string                 `json:"channel"`
	Data    map[string]interface{} `json:"data"`
}

type Path struct {
	Gtype string `json:"gtype"`
	Gid   string `json:"gid"`
}

type PathConstructor struct {
	Gtype string  `json:"gtype"`
	Gid   *string `json:"gid"`
}

type PathInput struct {
	Gtype string `json:"gtype"`
	Gid   string `json:"gid"`
}

type Paths struct {
	Paths []*Path `json:"paths"`
}

type Pong struct {
	Message string `json:"message"`
}

type SConnectFilter struct {
	Filter     *Filter                `json:"filter"`
	Gtype      string                 `json:"gtype"`
	Attributes map[string]interface{} `json:"attributes"`
	Directed   bool                   `json:"directed"`
	From       *PathInput             `json:"from"`
}

type Schema struct {
	ConnectionTypes []string        `json:"connection_types"`
	DocTypes        []string        `json:"doc_types"`
	Authorizers     *Authorizers    `json:"authorizers"`
	Validators      *TypeValidators `json:"validators"`
	Indexes         *Indexes        `json:"indexes"`
}

type TFilter struct {
	Root                 *PathInput `json:"root"`
	DocExpression        *string    `json:"doc_expression"`
	ConnectionExpression *string    `json:"connection_expression"`
	Limit                int        `json:"limit"`
	Sort                 *string    `json:"sort"`
}

type Traversal struct {
	Doc          *Doc      `json:"doc"`
	RelativePath *Paths    `json:"relative_path"`
	Direction    Direction `json:"direction"`
}

type Traversals struct {
	Traversals []*Traversal `json:"traversals"`
}

type TypeValidator struct {
	Name        string `json:"name"`
	Gtype       string `json:"gtype"`
	Expression  string `json:"expression"`
	Docs        *bool  `json:"docs"`
	Connections *bool  `json:"connections"`
}

type TypeValidatorInput struct {
	Name        string `json:"name"`
	Gtype       string `json:"gtype"`
	Expression  string `json:"expression"`
	Docs        *bool  `json:"docs"`
	Connections *bool  `json:"connections"`
}

type TypeValidators struct {
	Validators []*TypeValidator `json:"validators"`
}

type TypeValidatorsInput struct {
	Validators []*TypeValidatorInput `json:"validators"`
}

type Direction string

const (
	DirectionNone Direction = "NONE"
	DirectionFrom Direction = "FROM"
	DirectionTo   Direction = "TO"
)

var AllDirection = []Direction{
	DirectionNone,
	DirectionFrom,
	DirectionTo,
}

func (e Direction) IsValid() bool {
	switch e {
	case DirectionNone, DirectionFrom, DirectionTo:
		return true
	}
	return false
}

func (e Direction) String() string {
	return string(e)
}

func (e *Direction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Direction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Direction", str)
	}
	return nil
}

func (e Direction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
