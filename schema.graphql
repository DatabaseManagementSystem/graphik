scalar Time
scalar Map
scalar Empty

enum Algorithm {
  # BFS is short for the breadth-first search algorithm
  BFS
  # DFS is short for the depth-first search algorithm
  DFS
}

# Pong returns PONG if the server is healthy
type Pong {
  message: String!
}

# Ref describes a doc/connection type & id
type Ref {
  # gtype is the type of the doc/connection ex: pet
  gtype: String!
  # gid is the unique id of the doc/connection within the context of it's type
  gid: String!
}

# Doc is a Graph primitive representing a single entity/resource. It is connected to other docs via Connections
type Doc {
  # ref is the ref to the doc
  ref: Ref!
  # k/v pairs
  attributes: Map
}

# Docs is an array of docs
type Docs {
  # docs is an array of docs
  docs: [Doc!]
  seek_next: String!
}

type Traversal {
  doc: Doc!
  traversal_path: [Ref!]
  depth: Int!
  hops: Int!
}

type Traversals {
  traversals: [Traversal!]
}

type Refs {
  refs: [Ref!]
}

type TypeValidator {
  name: String!
  gtype: String!
  expression: String!
  # if docs is true, this validator will be applied to documents. Either docs or connections may be true, but not both.
  docs: Boolean
  # if docs is true, this validator will be applied to connections. Either docs or connections may be true, but not both.
  connections: Boolean
}

type TypeValidators {
  validators: [TypeValidator!]
}

# Connection is a graph primitive that represents a relationship between two docs
type Connection {
  # ref is the ref to the connection
  ref: Ref!
  # k/v pairs
  attributes: Map
  # directed is false if the connection is bi-directional
  directed: Boolean!
  # from is the doc ref that is the source of the connection
  from: Ref!
  # to is the doc ref that is the destination of the connection
  to: Ref!
}

# Connections is an array of connections
type Connections {
  connections: [Connection!]
  seek_next: String!
}

type Index {
  name: String!
  gtype: String!
  expression: String!
  docs: Boolean
  connections: Boolean
}

type Indexes {
  indexes: [Index!]
}

type Authorizer {
  name: String!
  expression: String!
}

type Authorizers {
  authorizers: [Authorizer!]
}

# Schema returns registered connection & doc types
type Schema {
  # connection_types are the types of connections in the graph
  connection_types: [String!]
  # doc_types are the types of docs in the graph
  doc_types: [String!]
  authorizers: Authorizers
  validators: TypeValidators
  indexes: Indexes
}

# Message is received on PubSub subscriptions
type Message {
  # channel is the channel the message was sent to
  channel: String!
  # data is the data sent with the message
  data: Map!
  # sender is the identity that sent the message
  sender: Ref!
  # timestamp is when the message was sent
  timestamp: Time!
}

# RefConstructor is used to create a Ref
input RefConstructor {
  gtype: String!
  gid: String
}

# DocConstructor is used to create a Doc
input DocConstructor {
  ref: RefConstructor!
  # attributes are k/v pairs
  attributes: Map
}

input DocConstructors {
  docs: [DocConstructor!]!
}

# ConnectionConstructor is used to create an Connection
input ConnectionConstructor {
  ref: RefConstructor!
  # directed is false if the connection is bi-directional
  directed: Boolean!

  attributes: Map
  # from is the doc ref that is the source of the connection
  from: RefInput!
  # to is the doc ref that is the destination of the connection
  to: RefInput!
}

input ConnectionConstructors {
  connections: [ConnectionConstructor!]!
}

# RefInput is the ref to a doc/connection
input RefInput {
  # ref is the ref to the target doc/connection to edit
  gtype: String!
  # ref is the ref to the target doc/connection to edit
  gid: String!
}

# Filter is a generic filter using Common Expression Language
input Filter {
  # gtype is the doc/connection type to be filtered
  gtype: String!
  # expression is a CEL expression used to filter connections/nodes
  expression: String
  # limit is the maximum number of items to return
  limit: Int!
  # custom sorting of the results.
  sort: String
  # seek to a specific key for pagination
  seek: String
  # reverse the results
  reverse: Boolean
  # search in a specific index
  index: String
}

input SConnectFilter {
  filter: Filter!
  gtype: String!
  attributes: Map
  directed: Boolean!
  from: RefInput!
}

input AggFilter {
  filter: Filter!
  aggregate: String!
  field: String
}

input TFilter {
  # gtype is the doc/connection type to be filtered
  root: RefInput!
  # expression is a CEL expression used to filter connections/nodes
  doc_expression: String
  connection_expression: String
  # limit is the maximum number of items to return
  limit: Int!
  # custom sorting of the results.
  sort: String
  # reverse the direction of the connection traversal
  reverse: Boolean
  # DFS(depth-first-search) or BFS(breadth-first-search). Defaults to breadth-first
  algorithm: Algorithm
  # maximum degree/depth of nodes to be visited during traversal
  max_depth: Int!
  # maximum number of nodes to be visited during traversal
  max_hops: Int!
}

# CFilter is used to fetch connections related to a single noted
input CFilter {
  # doc_ref is the ref to the target doc
  doc_ref: RefInput!
  # gtype is the type of connections to return
  gtype: String!
  # expression is a CEL expression used to filter connections
  expression: String,
  # limit is the maximum number of connections to return
  limit: Int!
  # custom sorting of the results.
  sort: String
  # seek to a specific key for pagination
  seek: String
  # reverse the results
  reverse: Boolean
}

# ChanFilter is used to filter messages in a pubsub channel
input ChanFilter {
  # channel is the target channel to listen on
  channel: String!
  # expression is a CEL expression used to filter messages
  expression: String
}

# Edit edites the attributes of a Doc or Connection
input Edit {
  # ref is the ref to the target doc/connection to edit
  ref: RefInput!
  # attributes are k/v pairs used to overwrite k/v pairs on a doc/connection
  attributes: Map!
}

# EFilter is used to edit/patch docs/connections
input EFilter {
  # filter is used to filter docs/connections to edit
  filter: Filter!
  # attributes are k/v pairs used to overwrite k/v pairs on a doc/connection
  attributes: Map!
}

# OutboundMessage is a message to be published to a pubsub channel
input OutboundMessage {
  # channel is the target channel to send the message to
  channel: String!
  # data is the data to send with the message
  data: Map!
}

input ExprFilter {
  # expression is a CEL expression used to filter messages/docs/connections
  expression: String
}

input IndexInput {
  name: String!
  gtype: String!
  expression: String!
  docs: Boolean
  connections: Boolean
}

input IndexesInput {
  indexes: [IndexInput!]
}

input AuthorizerInput {
  name: String!
  expression: String!
}

input AuthorizersInput {
  authorizers: [AuthorizerInput!]
}

input TypeValidatorInput {
  name: String!
  gtype: String!
  expression: String!
  # if docs is true, this validator will be applied to documents. Either docs or connections may be true, but not both.
  docs: Boolean
  # if docs is true, this validator will be applied to connections. Either docs or connections may be true, but not both.
  connections: Boolean
}

input TypeValidatorsInput {
  validators: [TypeValidatorInput!]
}

input Exists {
  gtype: String!
  expression: String!
  seek: String
  index: String
  reverse: Boolean
}

type Mutation {
  # createDoc creates a single doc in the graph
  createDoc(input: DocConstructor!): Doc!
  createDocs(input: DocConstructors!): Docs!
  # editDoc edites a single doc in the graph
  editDoc(input: Edit!): Doc!
  # editDocs edites 0-many docs in the graph
  editDocs(input: EFilter!): Docs!
  delDoc(input: RefInput!): Empty
  delDocs(input: Filter!): Empty
  # createConnection creates a single connection in the graph
  createConnection(input: ConnectionConstructor!): Connection!
  createConnections(input: ConnectionConstructors!): Connections!
  # editConnection edites a single connection in the graph
  editConnection(input: Edit!): Connection!
  # editConnections edites 0-many connections in the graph
  editConnections(input: EFilter!): Connections!
  delConnection(input: RefInput!): Empty
  delConnections(input: Filter!): Empty
  # publish publishes a mesage to a pubsub channel
  publish(input: OutboundMessage!): Empty
  setIndexes(input: IndexesInput!): Empty
  setAuthorizers(input: AuthorizersInput!): Empty
  setTypeValidators(input: TypeValidatorsInput!): Empty
}

type Query {
  # ping checks if the server is healthy
  ping(where: Empty): Pong!
  # getSchema gets information about the graph schema
  getSchema(where: Empty): Schema!
  # me returns your identity + connections
  me(where: Empty): Doc!
  # getDoc gets a doc at the given ref
  getDoc(where: RefInput!): Doc!
  # searchDocs searches for 0-many docs
  searchDocs(where: Filter!): Docs!
  # traverse searches for 0-many docs using dfs search
  traverse(where: TFilter!): Traversals!
  # getConnection gets a connection at the given ref
  getConnection(where: RefInput!): Connection!
  existsDoc(where: Exists!): Boolean!
  existsConnection(where: Exists!): Boolean!
  hasDoc(where: RefInput!): Boolean!
  hasConnection(where: RefInput!): Boolean!
  # searchConnections searches for 0-many connections
  searchConnections(where: Filter!): Connections!
  # connectionsFrom returns connections from the given doc that pass the filter
  connectionsFrom(where: CFilter!): Connections!
  # connectionsTo returns connections to the given doc that pass the filter
  connectionsTo(where: CFilter!): Connections!
  aggregateDocs(where: AggFilter!): Float!
  aggregateConnections(where: AggFilter!): Float!
  searchAndConnect(where: SConnectFilter!): Connections!
}

type Subscription {
  # subscribe subscribes to a pubsub channel
  subscribe(where: ChanFilter!): Message!
}